#!/usr/bin/env python3
"""
Run coverage analysis on pre-generated tests from output/ConsolidatedTests
This script:
1. Verifies tests exist from option 1
2. Compiles source code with coverage flags
3. Runs the generated tests
4. Generates coverage reports using gcov/lcov
"""

import os
import sys
import subprocess
import json
import glob
from pathlib import Path

# Add src directory to path for imports
sys.path.insert(0, str(Path(__file__).parent))
from config_reader import get_project_path

def check_prerequisites():
    """Check if required tools are installed"""
    required = ['g++', 'gcov', 'lcov']
    missing = []
    
    for tool in required:
        try:
            subprocess.run([tool, '--version'], capture_output=True, check=True)
        except (subprocess.CalledProcessError, FileNotFoundError):
            missing.append(tool)
    
    if missing:
        print(f"âŒ Missing required tools: {', '.join(missing)}")
        print(f"Install with: sudo apt-get install {' '.join(missing)}")
        return False
    return True

def check_tests_exist():
    """Verify that tests have been generated by option 1"""
    test_dir = "output/ConsolidatedTests"
    test_metadata = os.path.join(test_dir, "test_metadata.json")
    
    if not os.path.exists(test_dir):
        print("âŒ Tests directory not found: output/ConsolidatedTests")
        print("   Please run Option 1 (Generate Unit Tests) first.")
        return False
    
    if not os.path.exists(test_metadata):
        print("âŒ Test metadata not found")
        print("   Please run Option 1 (Generate Unit Tests) first.")
        return False
    
    # Check if there are test executables
    bin_dir = os.path.join(test_dir, "bin")
    if not os.path.exists(bin_dir) or not os.listdir(bin_dir):
        print("âŒ No test executables found")
        print("   Please run Option 1 (Generate Unit Tests) first.")
        return False
    
    return True

def cleanup_old_coverage_data(bin_dir):
    """
    Clean up old coverage data files to ensure fresh results.
    This is part of the coverage workflow state machine.
    
    Args:
        bin_dir: Directory containing test binaries and coverage files
        
    Returns:
        tuple: (gcda_removed, gcno_info) - counts of files processed
    """
    import glob
    
    print("\nğŸ§¹ Cleaning up old coverage data...")
    print("  ğŸ“ State: Pre-test cleanup phase")
    
    # Clean up old .gcda files (coverage runtime data from previous runs)
    gcda_files = glob.glob(os.path.join(bin_dir, '*.gcda'))
    gcda_removed = 0
    
    if gcda_files:
        print(f"  ğŸ“ Found {len(gcda_files)} old .gcda files")
        for gcda_file in gcda_files:
            try:
                os.remove(gcda_file)
                gcda_removed += 1
            except Exception as e:
                print(f"  âš ï¸  Failed to remove {gcda_file}: {e}")
        print(f"  âœ… Removed {gcda_removed} old .gcda files")
    else:
        print("  â„¹ï¸  No old .gcda files to clean up")
    
    # Check for .gcno files (coverage compile-time data)
    # We don't remove these as they're needed for coverage measurement
    gcno_files = glob.glob(os.path.join(bin_dir, '*.gcno'))
    if gcno_files:
        print(f"  âœ… Found {len(gcno_files)} .gcno files (compile-time data)")
    else:
        print(f"  âš ï¸  Warning: No .gcno files found!")
        print(f"     Tests may not have been compiled with --coverage flag")
    
    print(f"  ğŸ“ State: Cleanup complete, ready for test execution")
    return (gcda_removed, len(gcno_files))

def run_tests_with_coverage():
    """Run the generated tests and collect coverage data"""
    print("\nğŸ§ª Running tests with coverage...")
    print("  ğŸ“ State: Test execution phase")
    
    test_dir = "output/ConsolidatedTests"
    bin_dir = os.path.join(test_dir, "bin")
    coverage_dir = "output/UnitTestCoverage"
    os.makedirs(coverage_dir, exist_ok=True)
    
    # Find all test executables (exclude .gcno and .gcda files)
    test_executables = []
    for file in os.listdir(bin_dir):
        file_path = os.path.join(bin_dir, file)
        # Skip coverage files
        if file.endswith('.gcno') or file.endswith('.gcda'):
            continue
        if os.path.isfile(file_path) and os.access(file_path, os.X_OK):
            test_executables.append(file)  # Just store the filename, not full path
    
    if not test_executables:
        print("âŒ No executable tests found")
        return False
    
    print(f"Found {len(test_executables)} test executables")
    
    # Clean up old coverage data (part of state machine workflow)
    cleanup_old_coverage_data(bin_dir)
    
    # Run each test from the bin directory so .gcda files are created in the right place
    passed = 0
    failed = 0
    for test_name in test_executables:
        try:
            # Run the test from within the bin directory
            result = subprocess.run(
                ['./' + test_name],
                capture_output=True,
                timeout=10,
                cwd=bin_dir  # Critical: run from bin directory
            )
            if result.returncode == 0:
                passed += 1
                print(f"  âœ… {test_name}")
            else:
                failed += 1
                print(f"  âŒ {test_name}")
        except subprocess.TimeoutExpired:
            failed += 1
            print(f"  â±ï¸  {test_name} (timeout)")
        except Exception as e:
            failed += 1
            print(f"  âŒ {test_name} ({e})")
    
    print(f"\nTest Results: {passed} passed, {failed} failed")
    
    # Verify that new .gcda files were created
    new_gcda_files = glob.glob(os.path.join(bin_dir, '*.gcda'))
    if new_gcda_files:
        print(f"âœ… Generated {len(new_gcda_files)} new .gcda coverage files")
    else:
        print("âš ï¸  Warning: No .gcda files were generated!")
        print("   This may indicate tests didn't run or weren't compiled with --coverage flag")
        return False
    
    return True

def generate_coverage_report():
    """Generate coverage report using gcov/lcov"""
    print("\nğŸ“Š Generating coverage report...")
    
    coverage_dir = "output/UnitTestCoverage"
    
    # Clean up old coverage data to ensure fresh results
    if os.path.exists(coverage_dir):
        import shutil
        print(f"  ğŸ§¹ Cleaning old coverage data from {coverage_dir}")
        shutil.rmtree(coverage_dir)
    
    os.makedirs(coverage_dir, exist_ok=True)
    
    # Point to the bin directory where .gcda files are located
    bin_dir = "output/ConsolidatedTests/bin"
    
    # Verify .gcda files exist before proceeding
    import glob
    gcda_files = glob.glob(os.path.join(bin_dir, '*.gcda'))
    if not gcda_files:
        print("âŒ No .gcda coverage files found!")
        print("   Tests must be run first to generate coverage data.")
        print("   Make sure tests are compiled with --coverage flag and executed successfully.")
        return False
    
    print(f"  ğŸ“ Found {len(gcda_files)} .gcda coverage files to process")
    
    # Clean up .gcda files that don't have corresponding .gcno files
    # These can't be processed by lcov/gcov and will cause errors
    removed_count = 0
    for gcda_file in gcda_files[:]:  # Use slice to avoid modifying list while iterating
        file_size = os.path.getsize(gcda_file)
        
        # Check 1: Remove empty files
        if file_size == 0:
            try:
                os.remove(gcda_file)
                removed_count += 1
                gcda_files.remove(gcda_file)
            except:
                pass
            continue
        
        # Check 2: Remove .gcda files without corresponding .gcno files
        gcno_file = gcda_file.replace('.gcda', '.gcno')
        if not os.path.exists(gcno_file):
            try:
                os.remove(gcda_file)
                removed_count += 1
                gcda_files.remove(gcda_file)
            except:
                pass
    
    if removed_count > 0:
        print(f"  ğŸ§¹ Removed {removed_count} orphaned/empty .gcda files")
        print(f"  ğŸ“ {len(gcda_files)} .gcda files remaining")
    else:
        print(f"  âœ… All .gcda files have corresponding .gcno files")
    
    # Initialize lcov with error handling for common issues
    try:
        result = subprocess.run([
            'lcov', '--capture',
            '--directory', bin_dir,  # Changed: look in bin directory where .gcda files are
            '--base-directory', '.',  # Set base directory to current directory
            '--output-file', os.path.join(coverage_dir, 'coverage.info'),
            '--ignore-errors', 'mismatch',  # Ignore mismatch errors
            '--ignore-errors', 'mismatch',  # (twice to suppress warning)
            '--ignore-errors', 'source',    # Ignore missing source files
            '--ignore-errors', 'source',    # (twice)
            '--ignore-errors', 'gcov',      # Ignore gcov errors
            '--ignore-errors', 'gcov',      # (twice)
            '--ignore-errors', 'empty',     # Ignore empty files
            '--ignore-errors', 'empty',     # (twice)
            '--ignore-errors', 'negative',  # Ignore negative hit counts
            '--ignore-errors', 'negative',  # (twice)
            '--ignore-errors', 'corrupt',   # Ignore corrupt .gcda files
            '--ignore-errors', 'corrupt',   # (twice)
            '--ignore-errors', 'graph',     # Ignore graph file errors
            '--ignore-errors', 'graph',     # (twice)
            '--keep-going',                 # Continue on errors
            '--rc', 'geninfo_unexecuted_blocks=1'  # Set unexecuted blocks to zero
        ], capture_output=True, text=True)
        
        # Debug output for troubleshooting
        print(f"  ğŸ“‹ lcov exit code: {result.returncode}")
        if result.stdout:
            print(f"  ğŸ“¤ lcov stdout (first 500 chars): {result.stdout[:500]}")
        if result.stderr:
            print(f"  âš ï¸  lcov stderr (first 500 chars): {result.stderr[:500]}")
        
        if result.returncode != 0:
            print(f"âš ï¸  lcov returned non-zero exit code: {result.returncode}")
            print("Attempting to continue with partial coverage data...")
        
        # Check if coverage.info was created and has content
        coverage_file = os.path.join(coverage_dir, 'coverage.info')
        if not os.path.exists(coverage_file):
            print(f"âŒ coverage.info file was not created at {coverage_file}")
            print("   Make sure tests were compiled with --coverage flag and executed.")
            print(f"   Debug: Check if .gcda files exist in {bin_dir}")
            return False
        
        file_size = os.path.getsize(coverage_file)
        print(f"  ğŸ“¦ coverage.info size: {file_size} bytes")
        
        if file_size == 0:
            print(f"âŒ No coverage data was collected (coverage.info is empty).")
            print("   Make sure tests were compiled with --coverage flag and executed.")
            print(f"   Debug: Check if .gcda files exist in {bin_dir}")
            return False
        
        # Get the current project path to filter coverage correctly
        project_path = get_project_path()
        project_full_path = str(os.path.abspath(project_path))
        print(f"  ğŸ“‚ Filtering coverage for project: {project_path}")
        
        # Filter coverage to only include the current project's source files (not system headers or test files)
        filtered_file = os.path.join(coverage_dir, 'coverage_filtered.info')
        
        # Remove old filtered file to avoid using stale data
        if os.path.exists(filtered_file):
            os.remove(filtered_file)
        
        # Try multiple patterns to handle different project structures
        # Pattern 1: Projects with src/ subdirectory (e.g., SampleApp/src/)
        # Pattern 2: Projects with files at root (e.g., tinyxml2/*.cpp)
        filter_patterns = [
            f'{project_full_path}/*',  # All files in project directory
        ]
        
        result = subprocess.run([
            'lcov',
            '--extract', coverage_file,
            *filter_patterns,  # Extract files matching any of these patterns
            '--output-file', filtered_file,
            '--ignore-errors', 'source'
        ], capture_output=True, text=True)
        
        # Use filtered file if it has content, otherwise use original
        if os.path.exists(filtered_file) and os.path.getsize(filtered_file) > 0:
            # Verify the filtered file actually has the right project
            with open(filtered_file, 'r') as f:
                filtered_content = f.read()
                if project_full_path in filtered_content:
                    coverage_file = filtered_file
                    print(f"  âœ… Filtered to {project_path} source files only")
                else:
                    print(f"  âš ï¸  Filter didn't match project files, using full coverage data")
        else:
            print(f"  âš ï¸  No project files found in coverage, using full coverage data")
        
        # Generate HTML report
        html_dir = os.path.join(coverage_dir, 'lcov_html')
        result = subprocess.run([
            'genhtml',
            coverage_file,
            '--output-directory', html_dir,
            '--ignore-errors', 'source'  # Ignore missing source files in HTML generation
        ], capture_output=True, text=True)
        
        if result.returncode != 0:
            print(f"âš ï¸  genhtml had issues: {result.stderr[:200]}")
        
        print(f"âœ… Coverage report generated:")
        print(f"   HTML: {html_dir}/index.html")
        print(f"   Data: {coverage_file}")
        
        # Generate text coverage report
        text_report_file = os.path.join(coverage_dir, 'coverage_report.txt')
        try:
            with open(text_report_file, 'w') as f:
                f.write("="*70 + "\n")
                f.write("Coverage Analysis Report\n")
                f.write("="*70 + "\n\n")
                
                # Get detailed coverage info
                summary_result = subprocess.run([
                    'lcov', '--summary', coverage_file
                ], capture_output=True, text=True)
                
                if summary_result.returncode == 0:
                    f.write(summary_result.stdout)
                    f.write("\n")
                    
                    # Also get list coverage for each file
                    list_result = subprocess.run([
                        'lcov', '--list', coverage_file
                    ], capture_output=True, text=True)
                    
                    if list_result.returncode == 0:
                        f.write("\nDetailed Coverage by File:\n")
                        f.write("-"*70 + "\n")
                        f.write(list_result.stdout)
                
                f.write("\n" + "="*70 + "\n")
                f.write(f"Report generated: {os.path.basename(coverage_file)}\n")
                f.write(f"HTML report: {html_dir}/index.html\n")
                f.write("="*70 + "\n")
            
            print(f"   Text: {text_report_file}")
            
            # Create a copy in root directory for easy access by users
            root_report = "coverage_report.txt"
            import shutil
            try:
                shutil.copy2(text_report_file, root_report)
                print(f"   Copy: {root_report} (for easy access)")
            except Exception as e:
                print(f"   âš ï¸  Could not create root copy: {e}")
        except Exception as e:
            print(f"   âš ï¸  Could not generate text report: {e}")
        
        # Display coverage summary if available
        try:
            summary_result = subprocess.run([
                'lcov', '--summary', coverage_file
            ], capture_output=True, text=True)
            if summary_result.returncode == 0:
                print("\nğŸ“ˆ Coverage Summary:")
                for line in summary_result.stdout.split('\n'):
                    if 'lines' in line or 'functions' in line:
                        print(f"   {line.strip()}")
        except:
            pass
        
        return True
        
    except subprocess.CalledProcessError as e:
        print(f"âš ï¸  Coverage report generation had issues: {e}")
        print("This is normal if tests weren't compiled with coverage flags.")
        print("The tests still ran successfully.")
        return False
    except Exception as e:
        print(f"âŒ Unexpected error: {e}")
        return False

def main():
    print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    print("â•‘         Coverage Analysis (Using Pre-Generated Tests)           â•‘")
    print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    print()
    
    # Check prerequisites
    if not check_prerequisites():
        return 1
    
    # Verify tests exist
    if not check_tests_exist():
        return 1
    
    print("âœ… Pre-generated tests found\n")
    
    # Run tests with coverage
    if not run_tests_with_coverage():
        return 1
    
    # Generate coverage report
    generate_coverage_report()
    
    print("\nâœ… Coverage analysis complete!")
    return 0

if __name__ == "__main__":
    sys.exit(main())
