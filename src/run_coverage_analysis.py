#!/usr/bin/env python3
"""
Run coverage analysis on pre-generated tests from output/ConsolidatedTests
This script:
1. Verifies tests exist from option 1
2. Compiles source code with coverage flags
3. Runs the generated tests
4. Generates coverage reports using gcov/lcov
"""

import os
import sys
import subprocess
import json
from pathlib import Path

def check_prerequisites():
    """Check if required tools are installed"""
    required = ['g++', 'gcov', 'lcov']
    missing = []
    
    for tool in required:
        try:
            subprocess.run([tool, '--version'], capture_output=True, check=True)
        except (subprocess.CalledProcessError, FileNotFoundError):
            missing.append(tool)
    
    if missing:
        print(f"âŒ Missing required tools: {', '.join(missing)}")
        print(f"Install with: sudo apt-get install {' '.join(missing)}")
        return False
    return True

def check_tests_exist():
    """Verify that tests have been generated by option 1"""
    test_dir = "output/ConsolidatedTests"
    test_metadata = os.path.join(test_dir, "test_metadata.json")
    
    if not os.path.exists(test_dir):
        print("âŒ Tests directory not found: output/ConsolidatedTests")
        print("   Please run Option 1 (Generate Unit Tests) first.")
        return False
    
    if not os.path.exists(test_metadata):
        print("âŒ Test metadata not found")
        print("   Please run Option 1 (Generate Unit Tests) first.")
        return False
    
    # Check if there are test executables
    bin_dir = os.path.join(test_dir, "bin")
    if not os.path.exists(bin_dir) or not os.listdir(bin_dir):
        print("âŒ No test executables found")
        print("   Please run Option 1 (Generate Unit Tests) first.")
        return False
    
    return True

def run_tests_with_coverage():
    """Run the generated tests and collect coverage data"""
    print("ğŸ§ª Running tests with coverage...")
    
    test_dir = "output/ConsolidatedTests"
    bin_dir = os.path.join(test_dir, "bin")
    coverage_dir = "output/UnitTestCoverage"
    os.makedirs(coverage_dir, exist_ok=True)
    
    # Find all test executables
    test_executables = []
    for file in os.listdir(bin_dir):
        file_path = os.path.join(bin_dir, file)
        if os.path.isfile(file_path) and os.access(file_path, os.X_OK):
            test_executables.append(file)  # Just store the filename, not full path
    
    if not test_executables:
        print("âŒ No executable tests found")
        return False
    
    print(f"Found {len(test_executables)} test executables")
    
    # Clean up old coverage data to ensure fresh results
    import glob
    for gcda_file in glob.glob(os.path.join(bin_dir, '*.gcda')):
        try:
            os.remove(gcda_file)
        except:
            pass
    
    # Run each test from the bin directory so .gcda files are created in the right place
    passed = 0
    failed = 0
    for test_name in test_executables:
        try:
            # Run the test from within the bin directory
            result = subprocess.run(
                ['./' + test_name],
                capture_output=True,
                timeout=10,
                cwd=bin_dir  # Critical: run from bin directory
            )
            if result.returncode == 0:
                passed += 1
                print(f"  âœ… {test_name}")
            else:
                failed += 1
                print(f"  âŒ {test_name}")
        except subprocess.TimeoutExpired:
            failed += 1
            print(f"  â±ï¸  {test_name} (timeout)")
        except Exception as e:
            failed += 1
            print(f"  âŒ {test_name} ({e})")
    
    print(f"\nTest Results: {passed} passed, {failed} failed")
    return True

def generate_coverage_report():
    """Generate coverage report using gcov/lcov"""
    print("\nğŸ“Š Generating coverage report...")
    
    coverage_dir = "output/UnitTestCoverage"
    os.makedirs(coverage_dir, exist_ok=True)
    
    # Point to the bin directory where .gcda files are located
    bin_dir = "output/ConsolidatedTests/bin"
    
    # Clean up empty .gcda files only (don't validate with gcov as it's slow and error-prone)
    import glob
    empty_count = 0
    for gcda_file in glob.glob(os.path.join(bin_dir, '*.gcda')):
        if os.path.getsize(gcda_file) == 0:
            try:
                os.remove(gcda_file)
                # Also remove the corresponding .gcno file
                gcno_file = gcda_file.replace('.gcda', '.gcno')
                if os.path.exists(gcno_file):
                    os.remove(gcno_file)
                empty_count += 1
            except:
                pass
    
    if empty_count > 0:
        print(f"  ğŸ§¹ Removed {empty_count} empty .gcda files")
    
    # Initialize lcov with error handling for common issues
    try:
        result = subprocess.run([
            'lcov', '--capture',
            '--directory', bin_dir,  # Changed: look in bin directory where .gcda files are
            '--base-directory', '.',  # Set base directory to current directory
            '--output-file', os.path.join(coverage_dir, 'coverage.info'),
            '--ignore-errors', 'mismatch',  # Ignore line mismatch errors
            '--ignore-errors', 'source',     # Ignore missing source files
            '--ignore-errors', 'gcov',       # Ignore gcov errors
            '--ignore-errors', 'empty',      # Ignore empty files
            '--rc', 'geninfo_unexecuted_blocks=1'  # Set unexecuted blocks to zero
        ], capture_output=True, text=True)
        
        if result.returncode != 0:
            print(f"âš ï¸  lcov had issues: {result.stderr[:200]}")
            print("Attempting to continue with partial coverage data...")
        
        # Check if coverage.info was created and has content
        coverage_file = os.path.join(coverage_dir, 'coverage.info')
        if not os.path.exists(coverage_file) or os.path.getsize(coverage_file) == 0:
            print(f"âŒ No coverage data was collected.")
            print("   Make sure tests were compiled with --coverage flag and executed.")
            print(f"   Debug: Check if .gcda files exist in {bin_dir}")
            return False
        
        # Filter coverage to only include project source files (not system headers or test files)
        filtered_file = os.path.join(coverage_dir, 'coverage_filtered.info')
        result = subprocess.run([
            'lcov',
            '--extract', coverage_file,
            '*/TestProjects/*/src/*',  # Only include project source files
            '--output-file', filtered_file,
            '--ignore-errors', 'source'
        ], capture_output=True, text=True)
        
        # Use filtered file if it has content, otherwise use original
        if os.path.exists(filtered_file) and os.path.getsize(filtered_file) > 0:
            coverage_file = filtered_file
        
        # Generate HTML report
        html_dir = os.path.join(coverage_dir, 'lcov_html')
        result = subprocess.run([
            'genhtml',
            coverage_file,
            '--output-directory', html_dir,
            '--ignore-errors', 'source'  # Ignore missing source files in HTML generation
        ], capture_output=True, text=True)
        
        if result.returncode != 0:
            print(f"âš ï¸  genhtml had issues: {result.stderr[:200]}")
        
        print(f"âœ… Coverage report generated:")
        print(f"   HTML: {html_dir}/index.html")
        print(f"   Data: {coverage_file}")
        
        # Generate text coverage report
        text_report_file = os.path.join(coverage_dir, 'coverage_report.txt')
        try:
            with open(text_report_file, 'w') as f:
                f.write("="*70 + "\n")
                f.write("Coverage Analysis Report\n")
                f.write("="*70 + "\n\n")
                
                # Get detailed coverage info
                summary_result = subprocess.run([
                    'lcov', '--summary', coverage_file
                ], capture_output=True, text=True)
                
                if summary_result.returncode == 0:
                    f.write(summary_result.stdout)
                    f.write("\n")
                    
                    # Also get list coverage for each file
                    list_result = subprocess.run([
                        'lcov', '--list', coverage_file
                    ], capture_output=True, text=True)
                    
                    if list_result.returncode == 0:
                        f.write("\nDetailed Coverage by File:\n")
                        f.write("-"*70 + "\n")
                        f.write(list_result.stdout)
                
                f.write("\n" + "="*70 + "\n")
                f.write(f"Report generated: {os.path.basename(coverage_file)}\n")
                f.write(f"HTML report: {html_dir}/index.html\n")
                f.write("="*70 + "\n")
            
            print(f"   Text: {text_report_file}")
        except Exception as e:
            print(f"   âš ï¸  Could not generate text report: {e}")
        
        # Display coverage summary if available
        try:
            summary_result = subprocess.run([
                'lcov', '--summary', coverage_file
            ], capture_output=True, text=True)
            if summary_result.returncode == 0:
                print("\nğŸ“ˆ Coverage Summary:")
                for line in summary_result.stdout.split('\n'):
                    if 'lines' in line or 'functions' in line:
                        print(f"   {line.strip()}")
        except:
            pass
        
        return True
        
    except subprocess.CalledProcessError as e:
        print(f"âš ï¸  Coverage report generation had issues: {e}")
        print("This is normal if tests weren't compiled with coverage flags.")
        print("The tests still ran successfully.")
        return False
    except Exception as e:
        print(f"âŒ Unexpected error: {e}")
        return False

def main():
    print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    print("â•‘         Coverage Analysis (Using Pre-Generated Tests)           â•‘")
    print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    print()
    
    # Check prerequisites
    if not check_prerequisites():
        return 1
    
    # Verify tests exist
    if not check_tests_exist():
        return 1
    
    print("âœ… Pre-generated tests found\n")
    
    # Run tests with coverage
    if not run_tests_with_coverage():
        return 1
    
    # Generate coverage report
    generate_coverage_report()
    
    print("\nâœ… Coverage analysis complete!")
    return 0

if __name__ == "__main__":
    sys.exit(main())
