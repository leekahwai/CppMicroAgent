#!/usr/bin/env python3
"""
Run coverage analysis on pre-generated tests from output/ConsolidatedTests
This script:
1. Verifies tests exist from option 1
2. Compiles source code with coverage flags
3. Runs the generated tests
4. Generates coverage reports using gcov/lcov
"""

import os
import sys
import subprocess
import json
from pathlib import Path

# Add src directory to path for imports
sys.path.insert(0, str(Path(__file__).parent))
from config_reader import get_project_path

def check_prerequisites():
    """Check if required tools are installed"""
    required = ['g++', 'gcov', 'lcov']
    missing = []
    
    for tool in required:
        try:
            subprocess.run([tool, '--version'], capture_output=True, check=True)
        except (subprocess.CalledProcessError, FileNotFoundError):
            missing.append(tool)
    
    if missing:
        print(f"‚ùå Missing required tools: {', '.join(missing)}")
        print(f"Install with: sudo apt-get install {' '.join(missing)}")
        return False
    return True

def check_tests_exist():
    """Verify that tests have been generated by option 1"""
    test_dir = "output/ConsolidatedTests"
    test_metadata = os.path.join(test_dir, "test_metadata.json")
    
    if not os.path.exists(test_dir):
        print("‚ùå Tests directory not found: output/ConsolidatedTests")
        print("   Please run Option 1 (Generate Unit Tests) first.")
        return False
    
    if not os.path.exists(test_metadata):
        print("‚ùå Test metadata not found")
        print("   Please run Option 1 (Generate Unit Tests) first.")
        return False
    
    # Check if there are test executables
    bin_dir = os.path.join(test_dir, "bin")
    if not os.path.exists(bin_dir) or not os.listdir(bin_dir):
        print("‚ùå No test executables found")
        print("   Please run Option 1 (Generate Unit Tests) first.")
        return False
    
    return True

def run_tests_with_coverage():
    """Run the generated tests and collect coverage data"""
    print("üß™ Running tests with coverage...")
    
    test_dir = "output/ConsolidatedTests"
    bin_dir = os.path.join(test_dir, "bin")
    coverage_dir = "output/UnitTestCoverage"
    os.makedirs(coverage_dir, exist_ok=True)
    
    # Find all test executables (exclude .gcno and .gcda files)
    test_executables = []
    for file in os.listdir(bin_dir):
        file_path = os.path.join(bin_dir, file)
        # Skip coverage files
        if file.endswith('.gcno') or file.endswith('.gcda'):
            continue
        if os.path.isfile(file_path) and os.access(file_path, os.X_OK):
            test_executables.append(file)  # Just store the filename, not full path
    
    if not test_executables:
        print("‚ùå No executable tests found")
        return False
    
    print(f"Found {len(test_executables)} test executables")
    
    # Clean up old coverage data to ensure fresh results
    import glob
    gcda_files = glob.glob(os.path.join(bin_dir, '*.gcda'))
    if gcda_files:
        print(f"  üßπ Cleaning up {len(gcda_files)} old .gcda files...")
        removed_count = 0
        for gcda_file in gcda_files:
            try:
                os.remove(gcda_file)
                removed_count += 1
            except Exception as e:
                print(f"  ‚ö†Ô∏è  Failed to remove {gcda_file}: {e}")
        print(f"  ‚úÖ Removed {removed_count} old .gcda files")
    else:
        print("  ‚ÑπÔ∏è  No old .gcda files to clean up")
    
    # Run each test from the bin directory so .gcda files are created in the right place
    passed = 0
    failed = 0
    for test_name in test_executables:
        try:
            # Run the test from within the bin directory
            result = subprocess.run(
                ['./' + test_name],
                capture_output=True,
                timeout=10,
                cwd=bin_dir  # Critical: run from bin directory
            )
            if result.returncode == 0:
                passed += 1
                print(f"  ‚úÖ {test_name}")
            else:
                failed += 1
                print(f"  ‚ùå {test_name}")
        except subprocess.TimeoutExpired:
            failed += 1
            print(f"  ‚è±Ô∏è  {test_name} (timeout)")
        except Exception as e:
            failed += 1
            print(f"  ‚ùå {test_name} ({e})")
    
    print(f"\nTest Results: {passed} passed, {failed} failed")
    
    # Verify that new .gcda files were created
    new_gcda_files = glob.glob(os.path.join(bin_dir, '*.gcda'))
    if new_gcda_files:
        print(f"‚úÖ Generated {len(new_gcda_files)} new .gcda coverage files")
    else:
        print("‚ö†Ô∏è  Warning: No .gcda files were generated!")
        print("   This may indicate tests didn't run or weren't compiled with --coverage flag")
        return False
    
    return True

def generate_coverage_report():
    """Generate coverage report using gcov/lcov"""
    print("\nüìä Generating coverage report...")
    
    coverage_dir = "output/UnitTestCoverage"
    os.makedirs(coverage_dir, exist_ok=True)
    
    # Point to the bin directory where .gcda files are located
    bin_dir = "output/ConsolidatedTests/bin"
    
    # Verify .gcda files exist before proceeding
    import glob
    gcda_files = glob.glob(os.path.join(bin_dir, '*.gcda'))
    if not gcda_files:
        print("‚ùå No .gcda coverage files found!")
        print("   Tests must be run first to generate coverage data.")
        print("   Make sure tests are compiled with --coverage flag and executed successfully.")
        return False
    
    print(f"  üìÅ Found {len(gcda_files)} .gcda coverage files to process")
    
    # Clean up empty .gcda files only (don't validate with gcov as it's slow and error-prone)
    empty_count = 0
    for gcda_file in gcda_files[:]:  # Use slice to avoid modifying list while iterating
        if os.path.getsize(gcda_file) == 0:
            try:
                os.remove(gcda_file)
                # Also remove the corresponding .gcno file
                gcno_file = gcda_file.replace('.gcda', '.gcno')
                if os.path.exists(gcno_file):
                    os.remove(gcno_file)
                empty_count += 1
                gcda_files.remove(gcda_file)
            except:
                pass
    
    if empty_count > 0:
        print(f"  üßπ Removed {empty_count} empty .gcda files")
        print(f"  üìÅ {len(gcda_files) - empty_count} valid .gcda files remaining")
    
    # Initialize lcov with error handling for common issues
    try:
        result = subprocess.run([
            'lcov', '--capture',
            '--directory', bin_dir,  # Changed: look in bin directory where .gcda files are
            '--base-directory', '.',  # Set base directory to current directory
            '--output-file', os.path.join(coverage_dir, 'coverage.info'),
            '--ignore-errors', 'mismatch',  # Ignore line mismatch errors
            '--ignore-errors', 'source',     # Ignore missing source files
            '--ignore-errors', 'gcov',       # Ignore gcov errors
            '--ignore-errors', 'empty',      # Ignore empty files
            '--rc', 'geninfo_unexecuted_blocks=1'  # Set unexecuted blocks to zero
        ], capture_output=True, text=True)
        
        if result.returncode != 0:
            print(f"‚ö†Ô∏è  lcov had issues: {result.stderr[:200]}")
            print("Attempting to continue with partial coverage data...")
        
        # Check if coverage.info was created and has content
        coverage_file = os.path.join(coverage_dir, 'coverage.info')
        if not os.path.exists(coverage_file) or os.path.getsize(coverage_file) == 0:
            print(f"‚ùå No coverage data was collected.")
            print("   Make sure tests were compiled with --coverage flag and executed.")
            print(f"   Debug: Check if .gcda files exist in {bin_dir}")
            return False
        
        # Get the current project path to filter coverage correctly
        project_path = get_project_path()
        project_full_path = str(os.path.abspath(project_path))
        print(f"  üìÇ Filtering coverage for project: {project_path}")
        
        # Filter coverage to only include the current project's source files (not system headers or test files)
        filtered_file = os.path.join(coverage_dir, 'coverage_filtered.info')
        
        # Remove old filtered file to avoid using stale data
        if os.path.exists(filtered_file):
            os.remove(filtered_file)
        
        # Try multiple patterns to handle different project structures
        # Pattern 1: Projects with src/ subdirectory (e.g., SampleApp/src/)
        # Pattern 2: Projects with files at root (e.g., tinyxml2/*.cpp)
        filter_patterns = [
            f'{project_full_path}/*',  # All files in project directory
        ]
        
        result = subprocess.run([
            'lcov',
            '--extract', coverage_file,
            *filter_patterns,  # Extract files matching any of these patterns
            '--output-file', filtered_file,
            '--ignore-errors', 'source'
        ], capture_output=True, text=True)
        
        # Use filtered file if it has content, otherwise use original
        if os.path.exists(filtered_file) and os.path.getsize(filtered_file) > 0:
            # Verify the filtered file actually has the right project
            with open(filtered_file, 'r') as f:
                filtered_content = f.read()
                if project_full_path in filtered_content:
                    coverage_file = filtered_file
                    print(f"  ‚úÖ Filtered to {project_path} source files only")
                else:
                    print(f"  ‚ö†Ô∏è  Filter didn't match project files, using full coverage data")
        else:
            print(f"  ‚ö†Ô∏è  No project files found in coverage, using full coverage data")
        
        # Generate HTML report
        html_dir = os.path.join(coverage_dir, 'lcov_html')
        result = subprocess.run([
            'genhtml',
            coverage_file,
            '--output-directory', html_dir,
            '--ignore-errors', 'source'  # Ignore missing source files in HTML generation
        ], capture_output=True, text=True)
        
        if result.returncode != 0:
            print(f"‚ö†Ô∏è  genhtml had issues: {result.stderr[:200]}")
        
        print(f"‚úÖ Coverage report generated:")
        print(f"   HTML: {html_dir}/index.html")
        print(f"   Data: {coverage_file}")
        
        # Generate text coverage report
        text_report_file = os.path.join(coverage_dir, 'coverage_report.txt')
        try:
            with open(text_report_file, 'w') as f:
                f.write("="*70 + "\n")
                f.write("Coverage Analysis Report\n")
                f.write("="*70 + "\n\n")
                
                # Get detailed coverage info
                summary_result = subprocess.run([
                    'lcov', '--summary', coverage_file
                ], capture_output=True, text=True)
                
                if summary_result.returncode == 0:
                    f.write(summary_result.stdout)
                    f.write("\n")
                    
                    # Also get list coverage for each file
                    list_result = subprocess.run([
                        'lcov', '--list', coverage_file
                    ], capture_output=True, text=True)
                    
                    if list_result.returncode == 0:
                        f.write("\nDetailed Coverage by File:\n")
                        f.write("-"*70 + "\n")
                        f.write(list_result.stdout)
                
                f.write("\n" + "="*70 + "\n")
                f.write(f"Report generated: {os.path.basename(coverage_file)}\n")
                f.write(f"HTML report: {html_dir}/index.html\n")
                f.write("="*70 + "\n")
            
            print(f"   Text: {text_report_file}")
        except Exception as e:
            print(f"   ‚ö†Ô∏è  Could not generate text report: {e}")
        
        # Display coverage summary if available
        try:
            summary_result = subprocess.run([
                'lcov', '--summary', coverage_file
            ], capture_output=True, text=True)
            if summary_result.returncode == 0:
                print("\nüìà Coverage Summary:")
                for line in summary_result.stdout.split('\n'):
                    if 'lines' in line or 'functions' in line:
                        print(f"   {line.strip()}")
        except:
            pass
        
        return True
        
    except subprocess.CalledProcessError as e:
        print(f"‚ö†Ô∏è  Coverage report generation had issues: {e}")
        print("This is normal if tests weren't compiled with coverage flags.")
        print("The tests still ran successfully.")
        return False
    except Exception as e:
        print(f"‚ùå Unexpected error: {e}")
        return False

def main():
    print("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
    print("‚ïë         Coverage Analysis (Using Pre-Generated Tests)           ‚ïë")
    print("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
    print()
    
    # Check prerequisites
    if not check_prerequisites():
        return 1
    
    # Verify tests exist
    if not check_tests_exist():
        return 1
    
    print("‚úÖ Pre-generated tests found\n")
    
    # Run tests with coverage
    if not run_tests_with_coverage():
        return 1
    
    # Generate coverage report
    generate_coverage_report()
    
    print("\n‚úÖ Coverage analysis complete!")
    return 0

if __name__ == "__main__":
    sys.exit(main())
